<!DOCTYPE html>
<html>
    <head>
        <title>Input Model</title>
        <link rel="stylesheet" href ="index.css">
        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>
    </head>
    <body>

        <div id ="content">
            <h3 id = "subTitle">version </h3>
            <p id = "explanation">Create and train your model in https://ml-machine.org/. Save your model and then drag and drop your file into the box here.</p>
            <p>Current functionality: drag and drop the JSON data file into the box and click train model</p>
            <p>Once the model is ready click the create blocks button</p>
            <p id ="JSONButton" onclick = "parseJSON()">Train model</p>
            <p id ="writeButton" onclick = "writeMain()">Model not Ready</p>
        </div>
        <div id = "fileInputSpace" >
                <p id = "inputFileMes">Drag and Drop files here</p>
        </div>
    </body>
    <script>
        //so atm you put in dataset the parse
        //then press write to create the .ts info 
        //then drag and drop the jason
        //last click create blocks button and hope
        let dropEl = document.getElementById("fileInputSpace");
        var extId = window.location.hash.substr(1);
        var array = [];
        let model = null;
        let obj = null;
        
        
        
        


        function tryAddBlock(){
            console.log("Try add block entered")
            //trying for communication between editor and extension 
            console.log(array[0])
            console.log(array[1])
            var msg = {
                id: Math.random().toString(),
                type: "pxtpkgext",
                action: "extwritecode",
                extId: extId,
                response: "true",
                body: {
                    code: array[0],
                    json: JSON.stringify(array[1], null, 2)
                }
            }
            array=[]
            window.parent.postMessage(msg, "*")
        }

        function parseJSON(){
            document.getElementById("writeButton").innerHTML = "Training...";
            obj = JSON.parse(array[0]);
            logData(obj);
            let [collected, labels] = collectData(obj)
            console.log(collected)
            //collected contains list of records([x,y,z]) so will need to loop through this once working
            let features = []
            for (let i =0;i<collected.length;i++){
                features.push(applyFilters(collected[i]))
            }
            
            console.log("data to apply filters to: ",collected[0])
            console.log("features: ", features)
            console.log("labels: ", labels)
            model = trainModel(features, labels, obj)
            console.log(typeof(model))
            array = []
        }
        //drag and drop dataset file then click parse json button
        //then press write button and then create blocks button before going back to the editor
        function writeMain(){
            console.log("enter writeMain")
            let text = ""
            text = writeBlocks(text)
            //console.log("text created: ",text)
            array.push(text)
            //console.log(writeJson())
            array.push(writeJson())
            tryAddBlock()

        }
        function writeJson(){
            let jsonFile = {
                "name": "pxt-addgestures",
                "description": "",
                "dependencies": {
                    "core": "*",
                    "radio": "*",
                    "microphone": "*"
                },
                "files": [
                    "main.blocks",
                    "main.ts"
                ],
                "testFiles": [
                    "test.ts"
                ],
                "targetVersions": {
                    "target": "6.0.25",
                    "targetId": "microbit"
                },
                "supportedTargets": [
                    "microbit"
                ],
                "preferredEditor": "tsprj"
            }
            //jsonFile = JSON.parse(jsonFile)
            return jsonFile
        }
        function writeBasic(text){

            text = text +'namespace mlGesture {\n //%block \nexport function showNew() {\nbasic.showString("New block added");}}'
            return text
        }
        function writeEvent(text){
            text = text +'namespace mlGesture {\n' 
                text = text +'//% block="on event gesture %mode" \n'
                text = text +' export function onEventGesture(mode: GestureSet, handler: () => void) {\n'
                text = text +'handler();}}\n'
            return text
        }
        function writeBlocks(text){
            numOfBlocks = obj.length
            text = text+ 'function emfun(){};\n'
            text = writePlaceHolders(text, numOfBlocks)
            text = text +'namespace mlGesture {\n'
            text =  writeBlock(text, numOfBlocks)
            text = text+'}\n'
            text =  writeForeverLoop(text, numOfBlocks)
            return text
        }
        function writePlaceHolders(text, num){
            for (let i=0;i<num;i++){
                text = text+'let gesHand'+i+' = emfun;\n'
            }
            return text
        }
        function writeBlock(text, index){
            for (let i =0;i<index;i++)
            {
                text = text +'//% block="on event gesture '+i+'" \n'
                text = text +' export function onEventGesture'+i+'( handler: () => void) {\n'
                text = text +'gesHand'+i+' = handler;}\n'
            }
            return text
        }
        function writeForeverLoop(text, num){
            text = text+'basic.forever(function(){\n'
            text = text+'let num = Math.random()\n'
            text = text+'let gesNum = Math.round(num%2)\n'
            text = writeLoopIfs(text, num)
            text = text+'basic.pause(1000)\n'
            return text
        }
        function writeLoopIfs(text,num){
            for (let i=0;i<num;i++){
                text = text +'if (gesNum=='+i+')gesHand'+i+'()\n'
            }
            return text
        }
        function writeEnum(text){
            let names = []
            for (let i = 0;i<obj.length;i++){
                names.push(obj[i].name)
            }
            text = text+'enum GestureSet {\n'
            for (let i =0;i<names.length;i++)
            {
                text = text+'//% block="'+names[i] +'"\n'
                text = text+ 'Gesture'+i+',\n'
            }
            text = text+'}\n'

            return text
        }
        function logData(obj){
            console.log(obj)
            for (let i=0;i<obj.length;i++){
                console.log(obj[i].name)
                console.log("No. of recordings: ", obj[i].recordings.length)
            }
            console.log("obj.length: ",obj.length)
            console.log("obj[i].recordings.length: ",obj[0].recordings.length)


        }
        async function trainModel(features, labels, obj){
            
            const tensorFeatures = tf.tensor(features);
            const tensorLabels = tf.tensor(labels);

            // hardcoded but value should never change 
            const inputShape = [24];

            const input = tf.input({ shape: inputShape });
            console.log("input: ",input)
            const normalizer = tf.layers.batchNormalization().apply(input);
            const dense = tf.layers
            .dense({ units: 16, activation: 'relu' })
            .apply(normalizer);
            const softmax = tf.layers
            .dense({ units: obj.length, activation: 'softmax' })
            .apply(dense);

            const model = tf.model({ inputs: input, outputs: softmax });

            model.compile({
            loss: 'categoricalCrossentropy',
            optimizer: tf.train.sgd(0.5),
            metrics: ['accuracy'],
            });

            await model
            .fit(tensorFeatures, tensorLabels, {
                epochs: 80,
                batchSize: 16,
                validationSplit: 0.1,
            })
            .catch(err => {
                console.error('tensorflow training process failed:', err);
                return Promise.reject(err);
            });
            console.log("model Trained")
            document.getElementById("writeButton").innerHTML = "Create Blocks";

            console.log("model: ",model)

            //const save =  await model.save('downloads://my-model');
            console.log("model downloaded")
            return Promise.resolve(model);
        }
        //can make another function called collect records that will get the data from the JSON in the correct format for the apply filters function 
        //want this to output a 2D array 1[x,y,z], 2[x,y,z], 3[x,y,z]...
        function collectData(obj){
            var collection = [];
            let labels =[];//new Array(obj.length);
            //loop through each gesture ID
            for (let i =0;i<obj.length;i++){
                //loop through each recording 
                for (let k =0;k<obj[i].recordings.length;k++){
                    var recordings = [];
                    recordings.push(obj[i].recordings[k].data.x);
                    recordings.push(obj[i].recordings[k].data.y);
                    recordings.push(obj[i].recordings[k].data.z);
                    //console.log("recordings: ", recordings)
                    collection.push(recordings)
                    //console.log("current collection state: ",collection)
                    let newLabel = new Array(obj.length).fill(0)
                    newLabel[i] = 1
                    labels.push(newLabel)

                }
            }
            console.log("collection: ",collection)
            return [collection, labels];

        }
        function setListToInt(arr){
            var numArr = []
            console.log|("arr: ",arr)
            for (let i =0;i<arr.length;i++){
                numArr.push(parseInt(arr[i]))
            }
            console.log("numArr: ",numArr)
            return numArr
        }
        //function to be used per recording 
        function applyFilters(list){
            var features = [];
            //var numList = setListToInt(list)
            //console.log("numList: ",numList)
            for (let i =0;i<3;i++){
                //console.log(typeof(list[i]))
                //console.log("list: ",list[i])
                //max
                features.push(Math.max(...list[i]))
                //min
                features.push(Math.min(...list[i]))
                //mean
                features.push(findMean(list[i]))
                //stan dev
                features.push(findStanDev(list[i]))
                //peaks 
                features.push(peakFilter(list[i]))
                //total acc
                features.push(list[i].reduce((a, b) => a + Math.abs(b)));
                //zero crossing rate 
                features.push(zeroCrossingFilter(list[i]))
                //root mean square 
                features.push(Math.sqrt(list[i].reduce((a, b) => a + Math.pow(b, 2), 0) / list[i].length))
            }
            return features;
        }
        function findStanDev(list){
            let mean = findMean(list)
            let val = 0
            for (let i=0;i<list.length;i++){
                val = val +Math.pow(list[i]-mean, 2);
            }
            val = val/list.length
            val = Math.pow(val, 0.5)
            return val
        }
        function findMean(list){
            let val = 0
            for (let i=0;i<list.length;i++){
                val=val+list[i]
            }
            val = val/list.length
            return val
        }
        function zeroCrossingFilter(inValues){
            let count = 0;
            for (let i = 1; i < inValues.length; i++) {
            if (
                (inValues[i] >= 0 && inValues[i - 1] < 0) ||
                (inValues[i] < 0 && inValues[i - 1] >= 0)
            ) {
                count++;
            }
            }
            return count / (inValues.length - 1);

        }
        function peakFilter(inValues){
            const lag = 5;
            const threshold = 3.5;
            const influence = 0.5;

            let peaksCounter = 0;
            //console.log("inValues: ",inValues)
            if (inValues.length < lag + 2) {
            throw new Error('data sample is too short');
            }

            // init variables
            const signals = Array(inValues.length).fill(0);
            const filteredY = inValues.slice(0);
            const lead_in = inValues.slice(0, lag);

            const avgFilter = [];
            avgFilter[lag - 1] = findMean(lead_in);
            const stdFilter = [];
            stdFilter[lag - 1] = findStanDev(lead_in);

            for (let i = lag; i < inValues.length; i++) {
            if (
                Math.abs(inValues[i] - avgFilter[i - 1]) > 0.1 &&
                Math.abs(inValues[i] - avgFilter[i - 1]) > threshold * stdFilter[i - 1]
            ) {
                if (inValues[i] > avgFilter[i - 1]) {
                signals[i] = +1; // positive signal
                if (i - 1 > 0 && signals[i - 1] == 0) {
                    peaksCounter++;
                }
                } else {
                signals[i] = -1; // negative signal
                }
                // make influence lower
                filteredY[i] = influence * inValues[i] + (1 - influence) * filteredY[i - 1];
            } else {
                signals[i] = 0; // no signal
                filteredY[i] = inValues[i];
            }

            // adjust the filters
            const y_lag = filteredY.slice(i - lag, i);
            avgFilter[i] = findMean(y_lag);
            stdFilter[i] = findStanDev(y_lag);
            }
            return peaksCounter;

        }
        
        dropEl.addEventListener("drop", event => {
            console.log("double check");
            let file = event.dataTransfer.files[0];
            document.getElementById("inputFileMes").textContent = file.name;
            //console.log(file);
            //console.log(file.size);
            reader = new FileReader()
            reader.onload = function(event){
                //console.log(reader.result);
                array.push(reader.result)
                
            }
            reader.readAsText(file)
        });

        ["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"].forEach(eventName => {
            dropEl.addEventListener(eventName, event => {
                event.preventDefault();
                event.stopPropagation();
            });
        });


        ["dragover", "dragenter"].forEach(eventName => {
            dropEl.addEventListener(eventName, event => {
                dropEl.classList.add("hover");
            });
            //doesnt work as intended
            document.getElementById("fileInputSpace").backgroundColor = "#2079BD";
            document.getElementById("fileInputSpace").opacity = .5;
        });

        ["dragleave", "dragend", "drop"].forEach(eventName => {
            dropEl.addEventListener(eventName, event => {
                dropEl.classList.remove("hover");
            });
        });

    </script>
</html>

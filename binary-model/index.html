
<!DOCTYPE html>
<html>
    <head>
        <title>Lets a go</title>
        <link rel ="stylesheet" href = "index.css">
    </head>
    <body>
        <div id = "instructions">
            <p>Guide to use the website</p>
            <p>plug your micro:bit into the USB of your computer </p>
            <p>click  to connect and select your micro:bit</p>
            <p>type what you want to call your recording into Record name and press enter</p>
            <p>Repeat this for time to record for (its is not reccomended go enter much larger than 5 seconds)</p>
            <p>You then press click to record, it will count down from 3 and then start recoring your input </p>
            <p>One of the slots will fill with your record and you are free to enter more records</p>
            <p>once you are done, click Analyse data. graphs will appear down the webpage analysing your recorings </p>
            <p>clicking Run Model will train and run a model that will take live input from your microbit and classify it as one of your types of record</p>
        </div>
        <div id ="grid-container">
            <button id = "testButton", onclick = "test()">click to connect</button>
            <form onsubmit="return changeRecord()", id = "recordNameInput">
                <label for="recordName">Record name: </label>
                <input type="text", id = "recordName", name = "recordName" >
            </form>
            <p id = "recordText">Current Record: </p>
            <p id = "showRecord">placehold</p>
           <form onsubmit="return changeTime()", id = "time-input">
                <label for="time-value">Time to record for: </label>
                <input type="text", id = "time-value", name = "time-value" >
            </form>
            <p id = "time-text">Current time: </p>
            <p id = "show-time">Default (5)</p> 
            
            
            <button id ="recordButton">click here to record </button>
            <p id = sign>Halted</p>
            <div id = "record-slots">
                <p id = "slot-1">slot-1-empty</p>
                <p id = "slot-2">slot-2-empty</p>
                <p id = "slot-3">slot-3-empty</p>
                <p id = "slot-4">slot-4-empty</p>
                <p id = "slot-5">slot-5-empty</p>
            </div>
            <button id="analyse-button">Analyse data</button>
            <button id="run-model-button">Run Model</button>
            <button id ="end-run">Stop Model</button>
            <div id = "model-outputs">
                <p>Current prediction: </p>
                <p id ="current-predict">test text</p>
                <p>Last prediction: </p>
                <p id ="last-predict">test text</p>
            </div>
            <div id = "copys">
                <p id = "copy1"></p>
                <p id = "copy2"></p>
                <p id = "copy3"></p>
                <p id = "copy4"></p>
                <p id = "copy5"></p>
                <p id = "copy6"></p>
                <p id = "copy7"></p>
                <p id = "copy8"></p>
                <p id = "copy9"></p>
            </div>
            
            <div id = "todo">
                <p>Next tasks to do:</p>
                <p>create editor extension</p>
                <p>work on dynamically adding records</p>
                <p>work on deleting records</p>
                <p>look into live graphs</p>

            </div>
            <div id = "graph1-slot">
                <p>y-axis represents no of button presses</p>
                <canvas id = "graph1", style = "width:100%;max-width:700px"></canvas>
                <p>Total time button pressed (scale: 1 unit = 20ms)</p>
            </div>
            <div id = "graph2-slot">
                <canvas id = "graph2", style = "width:100%;max-width:700px"></canvas>
                <p>Aversage time buttons are held down (scale: 1 unit = 20ms)</p>
            </div>
            <div id = "graph3-slot">
                <canvas id = "graph3", style = "width:100%;max-width:700px"></canvas>
                <p>Minumum time buttons are held (scale: 1 unit = 20ms)</p>
            </div>
            <div id = "graph4-slot">
                <canvas id = "graph4", style = "width:100%;max-width:700px"></canvas>
                <p>Maximum time buttons are held (scale: 1 unit = 20ms)</p>
            </div>
            <div id = "graph5-slot">
                <canvas id = "graph5", style = "width:100%;max-width:700px"></canvas>
                <p>number of time buttons are held longer than 300ms</p>
            </div>
        </div>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>

        <script >

    

            let data = []
            let currentTime = 5
            let cont = true
            let analysisData = []
            let resultNames =[]
            let port = null
            let reader = null
            let writer = null
            let currentRecordName = ""
            let savedRecords = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]         
    let recordNames = ['tap', 'tap', 'tap', 'dashes', 'dashes', 'dashes', 'mix', 'mix', 'mix']

            let slotNames = ["","","","",""]
            async function connect(){
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200});
                console.log("test start")
                reader = port.readable.getReader()
            }
            function test(){
                document.getElementById("sign").textContent = "test"
            }
            async function justdoit(){
                while (port.readable){
                    let {done,value} = await reader.read();
                    if (value){
                        let decoder = new TextDecoder("utf-8");
                        let text = decoder.decode(value)
                        data.push([[Date.now()],text])
                        //create 2d array to store time and data
                    }
                    else{
                        console.log("no value")
                        reader.releaseLock()
                    }
                }
                console.log("when is here reached")
                port.close()

            }

            //coded in slots
            //not run with justdoit or time outs back in yet but its 6pm and i want to do a shop
            async function recordData(){
                console.log("record data ")
                sign.textContent = "Recording starts in 3..."
                await new Promise(r => setTimeout(r,1000))
                sign.textContent = "Recording starts in 2..."
                await new Promise(r => setTimeout(r,1000))
                sign.textContent = "Recording starts in 1..."
                await new Promise(r => setTimeout(r,1000))
                let startTime = Date.now()
                data = []
                sign.style.color = "red"
                sign.textContent = "Recording"
                justdoit()
                for (let i=0;i<currentTime;i++){
                    sign.textContent = "Recording "+(i+1)
                    await new Promise(r => setTimeout(r,1000))

                }

                let dataSet = data
                let sortedData = []
                let hold = null
                let startData = [] 
                for (let i =0;i<dataSet.length;i++){
                    //if (data[i][1].charAt(0)=="1")
                    if (data[i][1].length<5) sortedData.push(dataSet[i][1])
                    startData.push(dataSet[i][0]-startTime, dataSet[i][1])
                }
                console.log("start data: ", startData)
                console.log(sortedData)
                console.log("after loop")
                sign.style.color = "green"
                sign.textContent = "Halted"
                //forever loop used in makecode so record how long button is continuously held for 
                //foreveer sends message around avary 25ms
                //could work around and code own solution but it works well for now 
                savedRecords.push(sortedData)
                recordNames.push(currentRecordName)
                if (slotNames.indexOf(currentRecordName)!=-1){
                    updateRecordStatus(currentRecordName, slotNames.indexOf(currentRecordName))
                }
                else{
                    //create new list
                    //search through slotNames for first non "" and update 
                    //update the <p>
                    for (let i=0;i<slotNames.length;i++){
                        if (slotNames[i]==""){
                            slotNames[i] = currentRecordName;
                            console.log("slot-"+(i+1))
                            document.getElementById("slot-"+(i+1)).textContent = currentRecordName
                            updateRecordStatus(currentRecordName, i)
                            break
                        }
                    }
                }
                console.log("saved records: ",savedRecords)
            }
            function updateRecordStatus(name, index){
                console.log("enter function")
                let num = 0
                console.log(recordNames)
                for (let i=0;i<recordNames.length;i++){
                    if (recordNames[i] == name){
                        num++;
                    }
                }
                console.log("number of '"+name+"' recognised: "+num)
                document.getElementById("slot-"+(index+1)).textContent =( "Record '"+name+"' contains "+num+" records")

            }
            async function runModel(){
                console.log("enter run model")
                let model = null
                try{
                    model = await trainModel()
                    console.log("model returned")
                    console.log("model: ", model)
                }catch(error){
                    console.log(error)
                }
                console.log("after train model")
                data =[]
                cont = true
                justdoit()
                console.log("model running")
                let predFeatures = null
                let prediction = null
                //first run of predict, must wait for full record of data to come through
                
                await new Promise(r => setTimeout(r,(currentTime*1000)))
                    console.log(data.map(function(value, index){
                        if (value[1].length<2) return value[1];
                        else{return 0}}))
                    makePrediction(data, model)
                    
                    
                    //loop through, predict every 1 second using the last full records worth of data 
                    let inData = data
                    data = []
                    let test = [1,2,3,4,5,6]
                    console.log(test.slice(-3))
                    let num =0
                while (cont){
                    await new Promise(r => setTimeout(r,(1000)))
                    console.log(data.map(function(value, index){
                        if (value[1].length<2) return value[1];
                        else{return 0}}))
                        //add the newly colected data onto the end of the existig data
                        //take the end of the data to make t
                    console.log("data in checks ")
                    console.log("new data sample: ", data)
                    inData = inData.concat(data)
                    console.log("combined data sample: ", inData)
                    num = -(50*currentTime)
                    console.log("curretTime: ", currentTime)
                    console.log("num: ", num)
                    inData=inData.slice(num)
                    console.log("reduced data sample: ", inData)
                    makePrediction(inData, model)
                    data=[]
                    
                }
                console.log("data input stopped")

            }
            async function makePrediction(inData, model){
                let predFeatures = null
                let prediction = null
                predFeatures = predictDataFeatures(inData.map(function(value, index){
                        if (value[1].length<2) return value[1];
                        else{return '0'}}))
                    prediction = model.call(tf.tensor([predFeatures,1]),training=false,verbose = 2)
                    let pls = tf.tensor(prediction)
                    console.log(pls)
                    let predictRes = tensorExtract(prediction)
                    console.log("predict res: ", predictRes)
                    let index = max(predictRes)
                    console.log("index: ", index)
                    

                    currentPredict.textContent = prediction
                    let display = resultNames[index]+" - "+predictRes[index]*100+"%"
                    console.log("display change")
                    lastPredict.textContent = display
                    sendToMicroBit(resultNames[index])
            }
            async function sendToMicroBit(message){
                const txtEncode = new TextEncoder()
                const writer = port.writable.getWriter()
                await writer.write(txtEncode.encode(message))
                writer.releaseLock()

            }
            //fumbly way to get data from tensor but the object was beng very annoying to extract data from 
            function tensorExtract(tensor){
                let data = []
                let word = String(tensor)
                console.log(word)
                let values = word.split("]")
                console.log("values: ", values)
                values = values.toString()
                values = values.split("[")
                values = values.toString()
                values = values.split(",")
                for (let i=0;i<values.length;i++){
                    if (values[i][0]==1 || values[i][0]==0){
                        data.push(Number(values[i]))
                    }
                    if (data.length==3)break
                }
                console.log(values)
                console.log("data: ", data)
                return data
            }
            function max(data){
                let index=0
                let max =0
                for (let i=0;i<data.length;i++){
                    if (data[i]>max){
                        max = data[i]
                        index=i
                    }
                }
                return index
            }
            function changeCont(){
                console.log("change cont")
                cont = false
            }
            //could rename justdoit to liveInput
            //labels should be 2d array each array should be the length of how many different types of record there are 
            //each should be populated with 0s with a 1 indicating which type of record the crrent record is 
            //e.g. [1,0,0][1,0,0][0,1,0],[0,0,1],[0,0,1],[0,0,1] for 6 records of type 1,1,2,3,3,3
            //features of the data, all data for one records, then the next and so on 
            // input shape is the shape of data for each record 
            async function trainModel(){
                console.log("train model entered")
                let data = setData()
                let features = data[0]
                let labels = data[1]
                let names = data[2]
                console.log("features: ", features)
                //console.log("labels: ", labels)
                //console.log("names: ", names)

                const tensorFeatures = tf.tensor(features);
                const tensorLabels = tf.tensor(labels);

                // Find the shape by looking at the first data point
                console.log("shape: ", features[0].length)
                const inputShape = [features[0].length];

                const input = tf.input({ shape: inputShape });
                const normalizer = tf.layers.batchNormalization().apply(input);
                const dense = tf.layers
                .dense({ units: 16, activation: 'relu' })
                .apply(normalizer);
                const softmax = tf.layers
                .dense({ units: names.length, activation: 'softmax' })
                .apply(dense);

                const model = tf.model({ inputs: input, outputs: softmax });

                model.compile({
                loss: 'categoricalCrossentropy',
                optimizer: tf.train.sgd(0.5),
                metrics: ['accuracy'],
                });
                earlyStop = tf.callbacks.earlyStopping(monitor="val_loss",
                    mode = "min",
                    patience=5,
                    restore_best_weights=true
                )
                for (let i = 0; i <80; i++) {
                await model
                    .fit(tensorFeatures, tensorLabels, {
                    epochs: 5,
                    batchSize: 16,
                    validationSplit: 0.1,
                    callbacks: [earlyStop]
                    })
                    .catch(err => {
                    console.error('tensorflow training process failed:', err);
                    return Promise.reject(err);
                    });
                //this.onFitIteration({
                //    epoch: i,
                //    loss: h.history.loss[0],
                //});
                //this commented section would require making this whole train model process into a class
                //from tests so far it does not seem esential
                }
                console.log("model trained")
                //console.log("model#############################: ", model)
                //console.log("h: ", h)
                //let promise1 = Promise.resolve(model);
                //console.log("after promise")
                //console.log("promise: ", promise1)
                return Promise.resolve(model)
            }


            function setData(){
                let names = []
                for (let i=0;i<recordNames.length;i++){
                    if (!names.includes(recordNames[i])){
                        names.push(recordNames[i])
                    }
                }
                //console.log("names: ",names)
                let labels = []
                let hold=[]
                //console.log("labels pre addition: ",labels)
                let organisedData = organiseData()
                //console.log("organised: ", organisedData)
                for (let i=0;i<organisedData.length;i++){
                    hold=[]
                    for (let k=0;k<names.length;k++){
                        if (organisedData[i][0]==names[k]){

                            hold.push(1)
                        }else{
                            hold.push(0)
                        }
                    }

                    labels.push(hold)
                }
                //console.log("labels: ",labels)
                let features = []
                for (let i=0;i<analysisData.length;i++){
                    features.push(analysisData[i][1])
                }
                console.log("features: ",features)
                return [features,labels, names]
            }
            
            //here im gonna look at different way that data can be taken from the recordings 
            //number of button presses
            //number of 1s
            //average length of button press
            //if wanting to recognise morse code type thimgs could look for number of button presses over threshold 
            //note: program unlikely to ba able ton accuratly predict morse code due to continuous nature of data prediction
            //savedRecords 
            //recordNames 
            //could also be worth analysing how often button presses pass a certain threshold of time 
            function analyseData(){
                console.log("start analyse data")
                //console.log("saved: ",savedRecords)
                let organisedData = organiseData()
                //print statements to allow copy paste recordings of sample data to save for future testing
                //document.getElementById("copy1").textContent = savedRecords[0]
                //document.getElementById("copy2").textContent = savedRecords[1]
                //document.getElementById("copy3").textContent = savedRecords[2]
                //document.getElementById("copy4").textContent = savedRecords[3]
                //document.getElementById("copy5").textContent = savedRecords[4]
                //document.getElementById("copy6").textContent = savedRecords[5]
                //document.getElementById("copy7").textContent = savedRecords[6]
                //document.getElementById("copy8").textContent = savedRecords[7]
                //document.getElementById("copy9").textContent = savedRecords[8]
                console.log("organised: ", organisedData)
                //next steps are to analyse the data
                //take measurments of the recordings
                //number of 1s
                //number of button presses
                //average length of button presses
                analysisData = findFeatures(organisedData)
               
                //console.log("[total, no press, avg, min, max]")
                //axis labels are wrong way around
                console.log("analysis data: ",analysisData)
                displayGraphs(1,analysisData,0,1,"Number of button presses","Total time buttons are pressed")
                displayGraphs(2,analysisData,2,1, "Number of button presses", "average time button is pressed")
                displayGraphs(3,analysisData,3,1, "Number of button presses", "minimum button pressed time")
                displayGraphs(4,analysisData,4,1, "Number of button presses", "maximum button pressed time")
                displayGraphs(5,analysisData,5,1, "Number of button presses", "number of treshold breaches")
            }
            //find features of predict data 
            function predictDataFeatures(startData){
                let indData =[]
                indData.push(totalButtonTime(startData))
                indData.push(noOfButtonPresses(startData))
                stats = avgButtonLength(startData)
                indData.push(stats[0])
                indData.push(stats[1])
                indData.push(stats[2])
                indData.push(stats[3])

                console.log("ind: ", indData)
                return indData

            }
            function findFeatures(data){
                let analysisData =[]
                let stats = []
                for (let i =0;i<data.length;i++){
                    let indData =[]
                    indData.push(totalButtonTime(data[i][1]))
                    indData.push(noOfButtonPresses(data[i][1]))
                    stats = avgButtonLength(data[i][1])
                    indData.push(stats[0])
                    indData.push(stats[1])
                    indData.push(stats[2])
                    indData.push(stats[3])

                    console.log("ind: ", indData)
                    analysisData.push([data[i][0],indData])
                }
                return analysisData

            }
            function displayGraphs(graphNo,data,index1,index2, label1, label2){
                
                //console.log("display graphs")
                //console.log(data)
                let inputData = preparedData(data,index1,index2)
                //console.log("inputdata: ",inputData)
                let backgroundColours = populateColours(data)
                //let backgroundColours =["#E84623","#E84623","#E84623","#3C8CE1","#3C8CE1","#3C8CE1","#46D23D","#46D23D","#46D23D"]
                let name = "graph"+graphNo
                const graph1 =new Chart(name,{
                    type:"scatter",
                    Legend: {
                        display: false,
                    },
                    options: {

                        scales:{
                            x: {
                                title:{
                                    display: true,
                                    text: label1
                                },
                            },
                            y: {
                                title:{
                                    display: true,
                                    text: label2
                                },
                            },
                        

                    }},
                    data:{
                        datasets:[{
                            pointRadius: 4,
                            pointBackgroundColor: backgroundColours,
                            data: inputData
                        }]
                    }
                })

            }
            function populateColours(data){
                //console.log("data: ", data)
                let colourOptions = ["#E84623","#3C8CE1","#46D23D", "#EBBA11", "#EB11CC"]
                let colourOutput = ["#E84623"]
                let colourPointer = 0
                for (let i =0;i<data.length-1;i++){
                    //console.log("Data point 1",data[i][0])
                    //console.log("Data point 1",data[i+1][0])
                    if (data[i][0]==data[i+1][0]){
                        colourOutput.push(colourOptions[colourPointer])
                    }else{
                        colourPointer++
                        colourOutput.push(colourOptions[colourPointer])
                    }

                }
                //console.log("colour output: ", colourOutput)
                return colourOutput
            }

            function preparedData(data,index1, index2){
                //console.log("prepare data")
                //console.log("index1: ", index1)
                //console.log("index2: ", index2)
                let inputData = []
                for (let i=0;i<data.length;i++){
                    inputData.push({x: data[i][1][index1], y: data[i][1][index2]})
                }
                //console.log("input data: ", inputData)
                return inputData

            }
            function avgButtonLength(data){
                //console.log("average button press time")
                let current = 0
                let count =0
                let counts = []
                for (let i =0;i<data.length;i++){
                    if (data[i]==1 && current == 0){
                        currrent=1
                    }
                    if (data[i]==0 && current == 1){
                        counts.push(count)
                        count =0
                        currrent=0
                    }
                    if (data[i]==1){
                        current =1
                        count++
                    }
                    if (data[i]==0){
                        current =0
                    }
                }
                if (count!=0){
                    counts.push(count)
                }
                let total = 0
                let min = 280
                let max = 0
                let thresholdCount = 0
                //console.log("counts: ",counts)
                for (let i =0;i<counts.length;i++){
                    if (counts[i]>max) max = counts[i]
                    if (counts[i]<min)min = counts[i]
                    if (counts[i]>15) thresholdCount++

                }
                for (let i =0;i<counts.length;i++){
                    total+=counts[i]
                }
                let avg = total/counts.length
                if (isNaN(avg)){
                    console.log("average was nan")
                    avg=0
                }
                if (min ==280){
                    min =0
                }
                console.log("total: ",total)
                console.log("avg: ",avg, " (",avg*20,"ms)")
                console.log("max: ", max, " (",max*20,"ms)")
                console.log("min: ", min, " (",min*20,"ms)")
                return [avg, min, max, thresholdCount]

            }
            function noOfButtonPresses(data){
                //console.log("no of button presses")
                let current = 0
                let count = 0
                for (let i =0;i<data.length;i++){
                    if (data[i]==1 && current == 0){
                        count++
                        currrent=1
                    }
                    if (data[i]==1){
                        current =1
                    }
                    if (data[i]==0){
                        current =0
                    }
                }
                //console.log("count: ",count)
                return count

            }
            function totalButtonTime(data){
                //console.log("total button time ")
                console.log(data)
                let count =0
                for (let i =0;i<data.length;i++){
                    if (data[i]==1){
                        count++
                    }
                }
                //console.log("count: ",count, " (",count*20,"ms)")
                return count


            }
            //re order data so that like named recordings are stored next to each other 
            function organiseData(){
                //get list of unique record names 
                let names = []
                for (let i=0;i<recordNames.length;i++){
                    if (!names.includes(recordNames[i])){
                        names.push(recordNames[i])
                    }
                }
                console.log("names: ",names)
                resultNames = names
                let holdList = []

                for (let i=0;i<names.length;i++){
                    for (let k=0;k<recordNames.length;k++){
                        //console.log("names: ",names[i])
                        //console.log("saved names: ", recordNames[k])
                        if (names[i]==recordNames[k]){
                            //console.log("matched")
                            holdList.push([names[i],savedRecords[k]])
                        }
                    }
                }
                return holdList
            }



            let sign = document.getElementById("sign")
            let button = document.getElementById("testButton")
            button.addEventListener("click", ()=>{
                connect()

            })
            let startRecord = document.getElementById("recordButton")
            startRecord.addEventListener("click", ()=>{
                recordData()
            })
            let analyse = document.getElementById("analyse-button")
            analyse.addEventListener("click", ()=>{
                analyseData()
            })
            let train = document.getElementById("run-model-button")
            train.addEventListener("click", ()=>{
                runModel()
            })
            let change = document.getElementById("end-run")
            change.addEventListener("click", ()=>{
                changeCont()
            })
            let lastPredict = document.getElementById("last-predict")
            
            let currentPredict = document.getElementById("current-predict")
           
            


//from what i can tell, errors here lead to the page refreshing which caises the error message to disappear 
//dynammically creating elements for new records here proved unecesserily difficult so will just provide slots for now 
            function changeRecord(){
                console.log("enter change record")
                currentRecordName = document.getElementById("recordName").value
                document.getElementById("showRecord").textContent = currentRecordName
                console.log(currentRecordName)
                return false;
            }
            function changeTime(){
                console.log("enter change time")
                currentTime = document.getElementById("time-value").value
                document.getElementById("show-time").textContent = currentTime
                console.log(currentTime)
                return false;
            }

            

        </script>


    </body>

</html>
